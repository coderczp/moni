                                基于内存映射的千万级数据处理框架
在计算机的世界里，采用分治法将大问题切分为多个小问题予以解决是非常优秀的思想。
分布式架构是分治思想的优秀实践,许多优秀的框架都采用分布式架构解决海量数据的使用和存储问题，
分布式架构给我们带来了'银弹',但同时也给我们带来了挑战，我们不得不面对数据切分后的合并问题.
在典型的数据库中间件架构中，往往抽象出逻辑的数据表概念,一个逻辑表对应多个物理表，写入的数据
会根据规则路由到指定的物理表，这不仅解决了海量数据的存储问题，还附带解决单点故障问题，在之
前依靠花大量成本购买昂贵服务器的架构中，一旦我们这个昂贵的家伙罢工，那么网站几乎就会陷入瘫
痪，而在分布式的场景中，对服务器的要求是比较低的，而且即使某个节点坏了，往往也只影响部分业
务。但是我们不得不面临新的挑战，在某些场景下，我们不得不从各个节点加载大量数据，从中筛选出
满足业务需求的几条数据，如执行以下SQL:
        select * from xxx limit 10000000,10
 我们不得不去每个节点加载1000w+10条数据，在其中筛选满足条件的10条，这将会对我们架构
的中枢节点造成巨大的压力，简单的解决办法是加大中枢节点的内存和CPU，在内中合并
 这些数据，但这不现实，相比于大量的业务数据，现今的内存容量小的太多太多，第二种方案是将这
 些数据先写到硬盘，再根据需求加载数据进行处理，相比内存而言，硬盘的大小能支持非常大的数据
 量，但是，如果有时间要求呢？如果每条与上述SQL类似的语句都需要几小时或数十小时的时间来运
 行，哪恐怕业务又会不断的抱怨了。我们先搁置这个问题，看一个比较常见的现象，在我们2G内存的
PC中，同时可以打开大型游戏，文本编辑器，浏览器，图片查看程序。。。，这些程序使用的内存往往
远超我们的物理内存，操作系统是如何调度这些程序的呢，技巧之一就是使用虚拟内存，每个进程
都有4G左右的虚拟内存空间(32bit),这些空间并不是真实的物理内存地址，他和物理内存或文件之间
存在映射关系，这个映射关系是在系统加载程序时创建好的，当内存不足时，OS会将使用较少的内存
块写到文件，需要时又读回内存，这部分操作虽然涉及I/O，但是与普通的I/O不同，一方面他总是按
块操作，另一方面他不会有二次读写问题(数据总是读写到系统的缓冲区中转),所以即使在2G的PC上运
行多个程序使用内存大于2G，你也感觉不到系统内存调度带来的影响,当然,这种感觉是相对的。既然OS
的虚拟内存机制利用文件实现也什么高效，我们为什么不用来解决上述问题呢，windows和linux都提供了
相应的接口，我们可以用来实现内存映射，幸运的是java已经支持这种内存映射特性，采用java可以快
速实现这样一套模拟OS的虚拟内存管理框架，Moni就是这样一套框架，初衷是作为我设计的mysql中间
件virtualDB的跨节点数据合并组件，后来在研究Mycat时发现Mycat也遇到这个问题，于是把我把
这部份抽出来作为一个独立的框架，并取名Moni。我为Moni设计了一套自动扩容和地址数据分离的数据
结构,Moni的数据存取非常快,本身几乎没有内存消耗。理论上容量只受限于硬盘大小，目前版本数据量建
议在亿级以内。Moni是一个非常轻巧的框架，总共4个类，类结构如下:
org.virtualdb.mpp
     MemMapBytesArray:用于存取byte[]的数据结构
     MemMapLongArray :用于存取long的数据结构 
     MemMapSorter    :上述数据结构的排序工具,实现了原地归并和堆排序
     MemMapUtil      :工具类
org.virtualdb.mpp.test
    ....     
通常只需关注 MemMapBytesArray,MemMapLongArray是为实现地址和数据分离而实现的,地址数据
分离是实现快速排序的基础,目前所有的排序算法都需要移动数据，这在数据量大时会造成巨大的时间消耗，有的
算法还会有巨大的空间消耗。有如下数组:
 [12,96,8,-1,45]
   0, 1,2, 3, 4
 常规的排序需要将-1移到0号索引，将8移到1号索引,依次类推。在数据长度不固定的数组中，每次数据的移动涉
 及空间的扩容和压缩，因此难以用常规的排序算法进行排序，即使实现了排序也非常耗时。
 我们换个思维进行排序，不移动数据，改为移动索引，如下：
[12,96,8,-1,45]
   0, 1,2, 3, 4
将-1的索引改为0,8的索引改为1,依此类推,实现对数据的排序。在原来的排序中所使用的索引是数组天然具有的
但在基于地址移动实现的排序中，我们必须自己记录索引，MemMapBytesArray就是采用这种方式实现在平坦
的巨大内存中区分不同的数据项，其排序也是依赖于这种实现。
 
 
     



